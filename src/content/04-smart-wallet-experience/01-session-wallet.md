# Session-based Smart Wallets - Bridging Intent Architecture to User Experience

**Time**: 15 minutes  
**Pre-requisite**: Understanding of intent architecture from Module 3

## Connecting Intent Architecture with User Experience

In the previous module, we built the on-chain infrastructure of our intent system with Verifier and Solver contracts. Now, we'll implement the final piece that bridges users to this infrastructure: **the smart wallet layer**.

```mermaid
graph TD
    User[User] -->|Uses| SmartWallet[Smart Wallet]
    SmartWallet -->|Creates & Signs| Intent[Intent]
    Intent -->|Submitted to| Verifier[Verifier Contract]
    Verifier -->|Validated Intent| Solver[Solver Contract]
    Solver -->|Executes| Blockchain[NEAR Blockchain]
```

The smart wallet serves as a critical abstraction layer that:

1. **Handles authentication** through session keys
2. **Simplifies intent creation** for users
3. **Manages transaction signing** with minimal user interaction
4. **Provides a Web2-like experience** on a Web3 infrastructure

## Understanding Session-based Smart Wallets

A traditional Web3 wallet requires the user to approve and sign every single transaction, creating significant UX friction. A session-based smart wallet solves this problem by allowing users to authorize a temporary session key with limited permissions that can perform actions on their behalf without requiring additional signatures.

> ðŸ’¡ **Web2 Parallel**: This is similar to how OAuth tokens work in Web2 applications. When you authorize a third-party app to access your Google account, you grant it specific permissions (scopes) without sharing your main password.

## NEAR's Function Call Access Keys

NEAR provides a powerful mechanism called **Function Call Access Keys** that enables session-based wallet functionality. These are limited-permission keys that:

- Can only call specific methods on specific contracts
- Have a capped allowance of NEAR tokens for gas fees
- Can optionally be time-limited
- Cannot transfer funds directly or modify the account in other ways

## The Complete Session Key Lifecycle

Understanding the full lifecycle of a session key is crucial:

1. **Generation**: A new key pair is generated by the dApp
2. **Authorization**: The user approves adding this as a Function Call Access Key to their account
3. **Storage**: The dApp securely stores the private key
4. **Usage**: The dApp uses the key to sign and send transactions
5. **Expiration/Revocation**: The key is eventually depleted, expires, or is revoked

Let's implement each step:

### 1. Generating a Session Key

```javascript
import { KeyPair } from "near-api-js";

// Generate a brand new key pair (typically done by the dApp)
function generateSessionKeyPair() {
  // Create a new ED25519 key pair
  const keyPair = KeyPair.fromRandom("ed25519");

  // Get the public key in a format ready for on-chain authorization
  const publicKey = keyPair.getPublicKey().toString();

  // The private key should be securely stored by the dApp
  const privateKey = keyPair.toString();

  return { publicKey, privateKey, keyPair };
}
```

### 2. Requesting User Authorization

```javascript
import { transactions, utils } from "near-api-js";

// Request the user to authorize this session key via their main wallet
async function authorizeSessionKey(
  userAccountId,
  sessionKeyPublicKey,
  contractId,
  methods
) {
  // Access the user's main wallet (e.g., NEAR Wallet, MyNearWallet)
  const walletConnection = await connectToWallet();

  // Create a transaction to add the session key as a Function Call Access Key
  const actions = [
    transactions.functionCallAccessKey(
      contractId, // The contract this key can call (e.g., your Verifier contract)
      methods, // Array of method names this key can call (e.g., ['verify_intent'])
      utils.format.parseNearAmount("0.25") // Allowance (max 0.25 NEAR for gas fees)
    ),
  ];

  // Redirect user to their wallet to approve this key addition
  await walletConnection.requestAddKey(
    sessionKeyPublicKey, // The public key to add
    actions // The permissions for this key
  );

  // After approval, the wallet will redirect back to your dApp
}
```

### 3. Securely Storing the Session Key

```javascript
// Store the session key (typically after receiving redirect from wallet)
function storeSessionKey(accountId, privateKey) {
  // For development ONLY - in production consider more secure options
  // or keeping the key in memory only for the current browser session
  const sessionData = {
    accountId,
    privateKey,
    createdAt: new Date().toISOString(),
  };

  // WARNING: localStorage is vulnerable to XSS attacks
  // This is a simplified example for demonstration purposes
  localStorage.setItem("nearSessionKey", JSON.stringify(sessionData));
}
```

> âš ï¸ **Security Warning**: Storing private keys in localStorage is convenient but vulnerable to cross-site scripting (XSS) attacks. For production applications, consider:
>
> - Storing keys in memory only for the current session
> - Using secure browser storage APIs if available
> - Encrypting keys with a user password before storage
> - Using a more secure key management solution

### 4. Using the Session Key for Transactions

```javascript
import { connect, keyStores, KeyPair } from "near-api-js";

// Setup a NEAR connection that uses the session key
async function createSessionConnection(accountId, privateKey) {
  // Create an in-memory keystore for the session key
  const keyStore = new keyStores.InMemoryKeyStore();

  // Load the private key into a KeyPair object
  const keyPair = KeyPair.fromString(privateKey);

  // Add the key to the keystore for the specified account
  await keyStore.setKey("testnet", accountId, keyPair);

  // Connect to NEAR with this keystore
  const near = await connect({
    networkId: "testnet",
    keyStore,
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
  });

  // Get the account object that will use the session key
  const account = await near.account(accountId);
  return account;
}

// Use the session to call a contract without user approval
async function callContractWithSession(
  sessionAccount,
  contractId,
  method,
  args
) {
  try {
    const result = await sessionAccount.functionCall({
      contractId,
      methodName: method,
      args,
      gas: "30000000000000", // 30 TGas
      attachedDeposit: "0", // No attached deposit
    });

    console.log("Transaction succeeded:", result.transaction.hash);
    return result;
  } catch (error) {
    console.error("Transaction failed:", error);

    // Handle errors like insufficient allowance or unauthorized method
    if (error.message.includes("Exceeded the allowance")) {
      // Session key has run out of its NEAR allowance
      // Prompt user to authorize a new session key
    }

    throw error;
  }
}
```

### 5. Managing Key Expiration and Revocation

For a complete implementation, you should also consider:

- **Tracking key usage**: Monitor the remaining allowance
- **Renewal**: Prompt the user to authorize a new key before the old one expires
- **Revocation UI**: Let users view and revoke active session keys
- **Auto-expiry**: Set time-based expiration for unused keys

## Putting It All Together

Here's how a typical session key flow works in a dApp:

```javascript
// On app initialization, check if we have a valid session key
async function initializeWallet() {
  const savedSession = localStorage.getItem("nearSessionKey");

  if (savedSession) {
    // We have a saved session key, try to use it
    const { accountId, privateKey } = JSON.parse(savedSession);
    return createSessionConnection(accountId, privateKey);
  } else {
    // No session key, we'll need to create one
    const { publicKey, privateKey } = generateSessionKeyPair();

    // Request user to authorize this key (will redirect to wallet)
    await authorizeSessionKey(
      "user.testnet", // User's account ID
      publicKey, // Our new public key
      "verifier.testnet", // The contract this key can call
      ["verify_intent", "verify_and_solve"] // Methods this key can call
    );

    // After redirect back from wallet:
    storeSessionKey("user.testnet", privateKey);
    return createSessionConnection("user.testnet", privateKey);
  }
}
```

## Linking to Our Intent Architecture

With our session-based smart wallet, we can now build a seamless user experience for our intent system:

1. User connects to our dApp and authorizes a session key (one-time approval)
2. Our dApp uses this session key to submit intents to the Verifier contract
3. The Verifier validates these intents and forwards them to Solvers
4. Users get all the benefits of the intent architecture without repetitive signing

In the next section, we'll explore how to implement secure key management and storage for our smart wallet.
